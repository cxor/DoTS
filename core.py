import numpy as np
import math
import matplotlib.pyplot as plt
from map import Map
from node import Node
from waypoint import Waypoint
import time
import itertools


def execute_simulation():
    nodes = []
    sinks = []
    
    total_nodes_packets_generated = 0
    total_nodes_packets_transferred = 0
    total_nodes_packets_lost = 0
    total_sinks_packets_received = 0
    total_sinks_packets_lost = 0
    summation_nodes_speed = 0
    summation_nodes_gen_rates = 0
    
    while len(nodes) < 11 and len(sinks) < 3:       # Voglio una mappa significativa, no?
        simulation_map = Map(topology="roads", size=[20,10])
        nodes = simulation_map.add_nodes()
        sinks = simulation_map.add_sinks()

    print(sinks)
    print("Topology: ")
    simulation_map.draw_topology()
    print("\nInitial condition: ")
    for i in range(len(nodes)):
        print(f"\nNode {i}", end="\n")
        print(f"  Start position: {nodes[i].get_start()} - Target waypoint: {nodes[i].get_target()}", end="\n")
        print(f"Path to be followed: {nodes[i].get_path()}")
        # print(str(nodes[i].get_position()))
    simulation_map.draw_with_nodes()
    # return

    # Now I try to get the nodes moving
    # by using t as time unit, the while loop iterates
    # through the points (coordinates) that compose the
    # path that each node has to repeatedly walk on 
    # that same path was decided at the beginning, during the 
    # generation of the map.
    # At each "clock" (each iteration) the nodes take one step
    # upon their path (thanks to the modulus operation with t)
    # and continue to go back and forth as long as we want (duration of the while loop)
    # obviously in order to move the nodes we must update the
    # status of the cell in the topology (lines where .topology is called)
    
    #fare un check se due nodi hanno la stessa posizione, in quel caso scambiare il messaggio
    
    t = -1 # time unit
    while(t<60):
        print("\n")
        t = t+1
        for node in nodes:
            path_len = len(node.get_path())
            
            old_coords = node.get_position()
            simulation_map.topology[old_coords[0]][old_coords[1]].set_status(1)
            s = node.get_speed()
            index_new_pos = int((s / 60) * t)       # since nodes have a speed, I make them change "area" in the map according to that
            new_coords = node.get_path()[index_new_pos%path_len]
            # new_coords = node.get_path()[t%path_len]
            node.set_position(new_coords)
            node.generate_packets()
            print(f"Node {node.get_id()} was in {old_coords} and now goes in {new_coords}")
            simulation_map.topology[new_coords[0]][new_coords[1]].set_status(2)
        for a, b in itertools.combinations(nodes, 2):
            if a.get_position() == b.get_position():
                a.exchange_message(b)
                b.exchange_message(a)
                
        for node in nodes:
            for sink in sinks:
                if node.get_position() == sink.get_position():
                    sink.message_exchange(node)
                    print("Sink and node on the same position")
                    
        print(f"Time = {t}")
        #print(chr(27) + "[2J") # escape sequence that clears the screen in linux terminal so that the drawing looks like it is updating itself
        simulation_map.draw_with_nodes()
        #time.sleep(1)
    
    for node in nodes:
        summation_nodes_speed += node.get_speed()
        summation_nodes_gen_rates += node.get_rate()
        total_nodes_packets_generated += node.n_packets_generated
        total_nodes_packets_transferred += node.n_packets_received
        total_nodes_packets_lost += node.n_packets_not_received
        #print(str(node) + "received " + str(node.get_n_received_packet()) + " not received " + str(node.get_n_not_received_packet()))
        #print(str(node) + "total packets generated : " + str(node.n_packets_generated))
        #print(str(node) + "queue packet gen :" +str(node.packets_generated.queue))
        #print(str(node) + "queue packet rec :" +str(node.packets_received.queue))
        print("\n")
        
    for sink in sinks:
        total_sinks_packets_received += sink.n_packets_received
        total_sinks_packets_lost += sink.n_packets_not_received
        #print(str(sink) + "received " + str(sink.n_packets_received))
        #print(str(sink) + "not received " + str(sink.n_packets_not_received))
    node_avg_speed = round(summation_nodes_speed/len(nodes),2)
    print("Average speed of nodes : "+ str(round(summation_nodes_speed/len(nodes),2))+ "km/h")  
    avg_node_gen_packet = round(summation_nodes_gen_rates/len(nodes),2)
    print("Average packets generation rate of nodes : "+ str(round(summation_nodes_gen_rates/len(nodes),2))+ " per step")  
    print("Total number of packets generated by nodes : "+str(total_nodes_packets_generated))
    print("Total number of packets transferred by nodes to other nodes : "+str(total_nodes_packets_transferred))
    print("Total number of packets lost by nodes : "+str(total_nodes_packets_lost))
    print("Total number of packets received by sinks : "+str(total_sinks_packets_received))
    print("Total number of packets lost by sinks : "+str(total_sinks_packets_lost))

    return len(nodes), len(sinks), node_avg_speed, avg_node_gen_packet, total_nodes_packets_generated, total_nodes_packets_transferred, total_nodes_packets_lost, total_sinks_packets_received, total_sinks_packets_lost
    

def main():

    n_nodes = []
    n_sinks = []
    node_avg_speed = []
    avg_node_gen_packet = []
    total_nodes_packets_generated = []
    total_nodes_packets_transferred = []
    total_nodes_packets_lost = []
    total_sinks_packets_received = []
    total_sinks_packets_lost = []
    sim_num = range(10)

    for sim in range(10):
        n_n, n_s, nas, angp, tnpg, tnpt, tnpl, tspr, tspl = execute_simulation()
        if(tnpt != 0 or tspr != 0 or tnpl!=0 or tspl!=0):
            n_nodes.append(n_n)
            n_sinks.append(n_s)
            node_avg_speed.append(nas)
            avg_node_gen_packet.append(angp)
            total_nodes_packets_generated.append(tnpg)
            total_nodes_packets_transferred.append(tnpt)
            total_nodes_packets_lost.append(tnpl)
            total_sinks_packets_received.append(tspr)
            total_sinks_packets_lost.append(tspl)

    print("\n\n")
    for i in range(len(n_nodes)):
        print("Simulazione " + str(i) + ") Nodi: " + str(n_nodes[i]) + ", Sinks: " + str(n_sinks[i]))
        print("Average speed of nodes : "+ str(node_avg_speed[i])+ "km/h")  
        print("Average packets generation rate of nodes : "+ str(avg_node_gen_packet[i])+ " per step")  
        print("Total number of packets generated by nodes : "+str(total_nodes_packets_generated[i]))
        print("Total number of packets transferred by nodes to other nodes : "+ str(total_nodes_packets_transferred[i]))
        print("Total number of packets lost by nodes : "+ str(total_nodes_packets_lost[i]))
        print("Total number of packets received by sinks : "+ str(total_sinks_packets_received[i]))
        print("Total number of packets lost by sinks : "+str(total_sinks_packets_lost[i]))

    sim_num = range(len(n_nodes))
    #plt.scatter(sim_num, node_avg_speed, marker='x')
    plt.scatter(sim_num, avg_node_gen_packet, marker='o')
    #plt.scatter(sim_num, total_nodes_packets_generated, marker='o', c='black')
    plt.scatter(sim_num, total_nodes_packets_transferred, marker='o', c='red')
    plt.scatter(sim_num, total_nodes_packets_lost, marker='o', c='brown')
    plt.scatter(sim_num, total_sinks_packets_received, marker='o', c='green')
    plt.scatter(sim_num, total_sinks_packets_lost, marker='o', c='yellow')
    plt.show()


if __name__ == "__main__":
    main()